### 브라우저의 렌더링 과정

1. 사용자가 특정 페이지에 접속하면 DNS(실제 서버가 어디에 있는지 알고있는 서버)가 연결해줄 곳을 찾는다. 그 후, HTML을 서버로부터 내려 받으면, 브라우저의 렌더링 엔진에서 이를 파싱한다.
2. 브라우저는 HTML 파싱을 진행하며 DOM 트리를 만들고, 이 때 Link 태그를 만나서 스타일시트를 내려 받는 경우 CSS 파싱을 통해 CSSOM 트리를 만든다.
3. 이 둘을 결합한 렌더 트리를 만들고, 레이아웃 작업을 통해 사용자에게 그려서 보여줄 영역을 계산한 뒤 화면에 뿌려준다.
4. 앞의 과정에서 스크립트 태그를 만나면 자바스크립트 코드 실행을 위해 파싱을 중단한다. 제어 권한을 자바스크립트 엔진에게 넘기고 자바스크립트 코드나 파일을 로드해서 파싱 후 실행한다.

### Repaint 와 Reflow란?

- 생성된 DOM 노드의 레이아웃(너비, 높이, 위치 등) 수치 변경 시 영향을 받은 모든 노드의 수치를 재계산하여, 렌더트리를 재생성하는 과정이 Reflow입니다. 이 과정이 끝난 후 재생성된 렌더 트리를 다시 그리는데 이 과정이 Repaint입니다.
- Reflow가 이루어졌다고 해서 항상 repaint가 되는 것이 아니며 레이아웃 수치에 영향을 끼치지 않는 background-color나 outline 같은 것이 변경되면 repaint 과정만 진행됩니다.

### GET과 POST의 차이는?

- 사용목적: GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다. GET은 DB의 SELECT와 가깝고 POST는 Create와 비슷하다.
- 요청에 body 유무: GET은 URL 파라미터에 요청하는 데이터를 담아서 보내기 때문에 HTTP 메세지에는 body가 없다. POST는 body에 데이터를 담아 보내기 때문에 body가 존재한다.
- 멱등성: GET 요청은 멱등이며, POST는 멱등이 아니다.

### PUT

- PUT은 REST API에서 update에 해당하며 해당 스키마의 모든 내용을 업데이트 할때 사용합니다.

---

#### 멱등성이란?

- 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. GET은 리소스를 조회하기 때문에 여러번 요청하더라도 같은 응답을 받는다. 반대로 POST는 서버가 변경될 수 있는 요청을 보내므로 멱등이 아니다.

---

### Promise와 Callback의 차이점은?

- promise는 자바스크립트에서 비동기를 간편하게 처리해주는 객체이다. 비동기 처리란 특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 것을 말한다.
- 프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용된다. 서버에서 데이터를 요청하고 받아올 때 API를 사용하는데, 데이터를 받아오기 전에 데이터를 표시하려고 하면 오류가 발생하거나 빈 화면이 뜬다. 이를 해결하기 위해 프로미스를 사용한다.
- 프로미스는 pending, fullfilled, rejected의 3가지 상태가 존재하며 resolve()를 실행하면 이행 상태가 된다. 이행 상테에서 then을 이용한 결과 처리 값을 받을 수 있고 실패는 reject()로 실행하여 실패 상태가 된다.

- callback함수는 비동기 처리를 했을 때 콜백 함수를 실행시킴으로써 비동기 작업이 완료가 되며, 콜백에서 작성한 어떠한 행동을 실행할 수 있다.
- 콜백 함수는 함수의 매개변수인 함수로, 비동기 처리에서 동기 처리를 할 때 주로 사용한다. 콜백 패턴의 문제점으로는 콜백함수의 중첩이 많아질수록 가독성이 떨어진다는 점이 있다.

- 콜백이 비동기 로직의 결과 값을 콜백 안에서만 처리하고 콜백 밖에서 비동기 처리의 결과를 알 수 없는 것에 비해 프로미스는 비동기 처리 결과가 promise 객체에 저장되기 때문에 코드 작성이 용이해진다.
- promise 클래스는 비동기 처리만을 위해 만들어졌기 때문에 resolve와 reject와 같은 함수들이 정의되어 있어 이를 활용하면 되지만 콜백 패턴은 자유도가 높은 대신 템플릿이 존재하지 않아 코드가 복잡해지고 에러 처리가 어렵다.

- 비동기 처리를 위해 async / await 문법이 최근에 나왔는데 이를 통해 기존의 콜백과 프로미스의 단점을 보완하고 읽기 좋은 코드를 작성할 수 있다.

### async-await과 Promise의 차이점은?

- promise는 클래스이므로 함수에 바로 적용 가능한 async-await이 함수형 컴포넌트에 더 적합하다. async-await는 비동기 코드를 동기 형태로 만들기 때문에 가독성이 더 높다.

### aync-await 사용 방법?

- async는 function 앞에 키워드를 붙이고 해당 함수는 항상 promise를 반환한다.
- 자바스크립트는 await 키워드를 만나면 프로미스가 처리될 때까지 기다린다. 결과는 그 이후 반환된다. await은 async 키워드를 사용한 함수에서만 사용 가능하다.
- 프로미스가 처리될 때까지 엔진이 다른 일을 할 수 있기 때문에 CPU 리소스가 낭비되지 않는다.

### 콜백 지옥이란?

- 콜백 함수가 결과값을 가지고 콜백을 다시 호출하고 그 결과 값으로 다시 콜백을 호출하게 되어 예외 처리시 에러 콜백과 try/catch블록 양쪽에서 모두 이루어지는 콜백이 난무하는 현상.
- 이를 완화하기 위해서는 인라인 함수에 이름을 붙이고, 코드를 간결하게 작성하고 모듈화하며, promise패턴을 사용하는 방법이 있다.

### var, let, const의 차이점

- var는 함수 레벨 스코프를 취하여 함수 내부에 선언되어 있을 경우 함수 외부에서는 참조가 불가능해진다. var는 선언 후 재할당이 가능하다.
- const와 let은 블럭 레벨 스코프를 취하기 때문에 조건문, 중괄호로 이루어진 블럭 내부에서 선언되었다면 외부에서 해당 변수에 대한 참조가 불가능해진다. let과 const는 재할당이 불가능하다.
- var의 경우 선언과 메모리 할당 초기화 처리가 동시에 이루어지므로 선언된 변수에 대한 참조가 가능하다. 하지만 let과 const는 선언만 이루어지므로 선언 이전에는 해당 변수에 대한 참조가 불가능하다.

### 클로저란?

- 클로저는 선언 당시의 함수가 스코프 체인의 도움으로 전역 범위에 도달할 때까지 현재 범위와 상위 함수의 범위, 그리고 그 상위 함수의 범위까지에 대한 변수와 매개변수를 기억하는 능력이다.
- 클로저는 현재 상태를 기억하고, 변경된 최신 상태를 유지하기 위해 사용하며, 전역 변수의 사용을 억제하고 정보를 은닉, 실수를 줄이기 위해 사용한다.

### 실행 컨텍스트란?

- 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미한다. 실행 컨텍스트는 스코프, this의 동작원리를 담고 있는 것을 말한다.
- 전역 컨텍스트와 함수 컨텍스트 2가지가 존재하며, 전역 컨텍스트 생성 후에 함수가 호출될 때마다 함수 컨텍스트가 생성된다.
- 컨텍스트 생성시 변수 객체, 스코프 체인, this가 생성된다. 컨텍스트 생성 후 함수에 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프 체인을 따라 올라가며 찾는다.
- 함수 실행이 마무리되면 해당 컨텍스트는 사라지고, 페이지가 종료되면 전역 컨텍스트도 사라진다.
  1. 변수객체
  - 실행 컨텍스트가 생성되면, 자바스크립트 엔진은 실행을 위해 필요한 여러 정보들을 담을 객체를 생성하는데, 이것이 변수 객체이다. 전역 컨텍스트는 변수 객체 안에 전역 함수 및 전역 변수를 저장하며, 함수 컨텍스트인 경우 이와 더불어 argument object를 함께 저장한다.
  2. 스코프 체인
  - 스코프 체인은 일종의 리스트로써 전역 객체와 중첩된 함수의 레퍼런스를 차례로 저장한다. 전역 또는 함수가 참조할 수 있는 변수 객체에 대해 저장하게 되며, 이는 실행 컨텍스트에서 상위 컨텍스트와 그 상위 컨텍스트의 변수 객체, 마지막으로는 전역 객체까지 참조할 수 있게된다. 자바스크립트 엔진은 스코프 체인을 통해 렉시컬 스코프를 파악한다. 상위 함수, 전역 스코프 등을 참조할 수 있는 이유가 스코프 체인이 검색을 하기 때문이다.. (렉시컬 환경은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다.)
  3. This
  - this에 할당되는 값은 함수의 호출 패턴에 의해 결정된다.

### 호이스팅이란?

- 호이스팅이란 변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 현상이다. 함수 표현식은 호이스팅이 적용되지 않고, 일반 함수 선언문은 함수 호이스팅이 적용된다.

### 프로토 타입이란?

- 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거했다. 기존의 코드를 재사용하여 중복을 제거하였으며, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 미리 프로토타입에 구현해 놓음으로써 상위 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.

### 프로토타입 체인?

- 객체의 프로퍼티에 접근하려고 할 때, 객체에 접근하려는 프로퍼티가 없으면,**proto**접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는 것을 말한다.
- 프로토타입체인의 최상위 객체는 Object.prototype이다.

### 불변성을 유지하려면 어떻게 해야하는가?

1. 스프레드 문법 사용

- 스프레드 문법을 사용해서 객체를 복사하면 객체가 불변성을 유지할 수 있다. 스프레드 문법을 1레벨 깊이에서만 유효하게 동작하기 때문에 객체 내부 객체의 불변성까지는 유지할 수 없다.

2. immer 라이브러리 사용

### This

- 자바스크립트는 함수 호출 방식에 따라서 this에 바인딩할 객체가 동적으로 결정된다.
- 일반 함수와 콜백 함수에서의 this는 전역 객체를 가리키며, 화살표 함수의 this는 언제나 상위 스코프의 this를 가리킨다. 메소드 호출 시에는 해당 메소드를 호출한 객체를 가리킨다. 생성자 함수 호출 시에는 생성하는 객체로 this가 바인딩된다.
- apply, call, bind는 특정 객체에 명시적으로 this를 바인딩하는 방법이다. apply의 경우는 두 번째 인자를 배열형태로 넣는 차이점만 빼고 call과 동일하다. bind는 함수에 인자로 전달한 this가 새로운 함수를 리턴한다. apply나 call과 같이 함수를 실행하지는 않기 때문에 명시적으로 함수를 호출할 필요가 있다.

### REST

- REST란 REpresentational State Transfer의 약자로, 웹에 존재하는 모든 자원에 고유한 URI를 부여해 활용하는 것이다. 자원을 정의하고 자원에 대한 주소를 지정하는 방법론을 의미한다. HTTP URI를 통해 자원을 명시하고, HTTP Method(POST, GET, DELETE, PUT)를 통해 해당 자원에 대한 CRUD 오퍼레이션을 적용하는 것이다.
- REST의 구성요소
  1. 자원(Resource): URI
  - 모든 자원에 고유한 ID가 존재하고 이 자원은 Server에 존재한다.
  - 자원을 구별하는 ID는 '/groups/:group_id'와 같은 HTTP URI다.
  - Client는 URI를 이용해서 자원을 지정하고, 해당 자원의 상태에 대한 조작을 서버에 요청한다.
  2. 행위
  - HTTP Method (POST, GET, PUT, DELETE)
  3. 표현
  - JSON, XML 등을 통해 데이터 주고받기
  - 클라이언트가 자원의 상태(정보)에 대한 조작을 요청하면 서버는 이에 적절한 응답(Representation)을 보낸다.

### REST API

- REST API는 REST 기반으로 서비스 API를 구현한 것으로, 각 요청이 어떤 동작이나 정보를 위한 것인지 요청 자체의 모습으로 추론이 가능하다.

### RESTful

- RESTful은 일반적으로 REST라는 아키텍처를 구현하는 웹 서비스를 나타내기 위해 사용되는 용어이다. REST API를 제공하는 웹 서비스를 RESTful하다고 할 수 있다.

### 이벤트 버블링

- 이벤트 버블링이란 한 요소에 이벤트가 발생하면 이 요소에 할당된 핸들러가 동작하고, 이어서 부모 요소의 핸들러가 동작하며 최상단의 부모 요소를 만날 때까지 반복되면서 핸들러가 동작하는 현상을 말한다.

### CSR과 SSR의 차이

- CSR의 과정: 서버가 브라우저에게 응답을 보냄 -> 브라우저는 JavaScript를 다운 받음 -> 브라우저는 리액트를 실행 -> 페이지가 보여지고 상호작용
- SSR의 과정: 서버가 브라우저에게 HTML응답 렌더링하기 위한 준비가 되었다고 보냄 -> 브라우저가 페이지 렌더링을 해서 페이지가 보여지고 브라우저는 JavaScript를 다운 받음 -> 브라우저 리액트 실행 -> 페이지 상호작용 가능
- CSR은 마지막 단계 전까지 화면에 보여지지가 않고 로딩중이지만 SSR은 미리 페이지가 보여진다. CSR은 초기 로딩 속도가 느리긴하지만 화면 전환이 클라이언트에서 이루어져 빠른 전환이 가능하다. SSR은 초기 로딩 속도가 빨라서 사용자가 느끼기엔 좋은 것 같지만 동작은 하지 않는다. 화면 전환을 서버에 요청해야하므로 서버에 부담을 줄 수도 있다.
