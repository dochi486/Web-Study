### 브라우저의 렌더링 과정

1. 사용자가 특정 페이지에 접속하면 DNS(실제 서버가 어디에 있는지 알고있는 서버)가 연결해줄 곳을 찾는다. 그 후, HTML을 서버로부터 내려 받으면, 브라우저의 렌더링 엔진에서 이를 파싱한다.
2. 브라우저는 HTML 파싱을 진행하며 DOM 트리를 만들고, 이 때 Link 태그를 만나서 스타일시트를 내려 받는 경우 CSS 파싱을 통해 CSSOM 트리를 만든다.
3. 이 둘을 결합한 렌더 트리를 만들고, 레이아웃 작업을 통해 사용자에게 그려서 보여줄 영역을 계산한 뒤 화면에 뿌려준다.
4. 앞의 과정에서 스크립트 태그를 만나면 자바스크립트 코드 실행을 위해 파싱을 중단한다. 제어 권한을 자바스크립트 엔진에게 넘기고 자바스크립트 코드나 파일을 로드해서 파싱 후 실행한다.

### Repaint 와 Reflow란?

- 생성된 DOM 노드의 레이아웃(너비, 높이, 위치 등) 수치 변경 시 영향을 받은 모든 노드의 수치를 재계산하여, 렌더트리를 재생성하는 과정이 Reflow입니다. 이 과정이 끝난 후 재생성된 렌더 트리를 다시 그리는데 이 과정이 Repaint입니다.
- Reflow가 이루어졌다고 해서 항상 repaint가 되는 것이 아니며 레이아웃 수치에 영향을 끼치지 않는 background-color나 outline 같은 것이 변경되면 repaint 과정만 진행됩니다.

### GET과 POST의 차이는?

- 사용목적: GET은 서버의 리소스에서 데이터를 요청할 때, POST는 서버의 리소스를 새로 생성하거나 업데이트할 때 사용한다. GET은 DB의 SELECT와 가깝고 POST는 Create와 비슷하다.
- 요청에 body 유무: GET은 URL 파라미터에 요청하는 데이터를 담아서 보내기 때문에 HTTP 메세지에는 body가 없다. POST는 body에 데이터를 담아 보내기 때문에 body가 존재한다.
- 멱등성: GET 요청은 멱등이며, POST는 멱등이 아니다.

---

#### 멱등성이란?

- 연산을 여러번 적용하더라도 결과가 달라지지 않는 성질을 의미한다. GET은 리소스를 조회하기 때문에 여러번 요청하더라도 같은 응답을 받는다. 반대로 POST는 서버가 변경될 수 있는 요청을 보내므로 멱등이 아니다.

---

### Promise와 Callback의 차이점은?

- promise는 자바스크립트에서 비동기를 간편하게 처리해주는 객체이다. 비동기 처리란 특정 코드의 실행이 완료될 때까지 기다리지 않고 다음 코드를 먼저 수행하는 것을 말한다.
- 프로미스는 주로 서버에서 받아온 데이터를 화면에 표시할 때 사용된다. 서버에서 데이터를 요청하고 받아올 때 API를 사용하는데, 데이터를 받아오기 전에 데이터를 표시하려고 하면 오류가 발생하거나 빈 화면이 뜬다. 이를 해결하기 위해 프로미스를 사용한다.
- 프로미스는 pending, fullfilled, rejected의 3가지 상태가 존재하며 resolve()를 실행하면 이행 상태가 된다. 이행 상테에서 then을 이용한 결과 처리 값을 받을 수 있고 실패는 reject()로 실행하여 실패 상태가 된다.

- callback함수는 비동기 처리를 했을 때 콜백 함수를 실행시킴으로써 비동기 작업이 완료가 되며, 콜백에서 작성한 어떠한 행동을 실행할 수 있다.
- 콜백 함수는 함수의 매개변수인 함수로, 비동기 처리에서 동기 처리를 할 때 주로 사용한다. 콜백 패턴의 문제점으로는 콜백함수의 중첩이 많아질수록 가독성이 떨어진다는 점이 있다.

- 콜백이 비동기 로직의 결과 값을 콜백 안에서만 처리하고 콜백 밖에서 비동기 처리의 결과를 알 수 없는 것에 비해 프로미스는 비동기 처리 결과가 promise 객체에 저장되기 때문에 코드 작성이 용이해진다.
- promise 클래스는 비동기 처리만을 위해 만들어졌기 때문에 resolve와 reject와 같은 함수들이 정의되어 있어 이를 활용하면 되지만 콜백 패턴은 자유도가 높은 대신 템플릿이 존재하지 않아 코드가 복잡해지고 에러 처리가 어렵다.

- 비동기 처리를 위해 async / await 문법이 최근에 나왔는데 이를 통해 기존의 콜백과 프로미스의 단점을 보완하고 읽기 좋은 코드를 작성할 수 있다.

### async-await과 Promise의 차이점은?

- promise는 클래스이므로 함수에 바로 적용 가능한 async-await이 함수형 컴포넌트에 더 적합하다. async-await는 비동기 코드를 동기 형태로 만들기 때문에 가독성이 더 높다.

### aync-await 사용 방법?

- async는 function 앞에 키워드를 붙이고 해당 함수는 항상 promise를 반환한다.
- 자바스크립트는 await 키워드를 만나면 프로미스가 처리될 때까지 기다린다. 결과는 그 이후 반환된다. await은 async 키워드를 사용한 함수에서만 사용 가능하다.
- 프로미스가 처리될 때까지 엔진이 다른 일을 할 수 있기 때문에 CPU 리소스가 낭비되지 않는다.

### var, let, const의 차이점

- var는 함수 레벨 스코프를 취하여 함수 내부에 선언되어 있을 경우 함수 외부에서는 참조가 불가능해진다. var는 선언 후 재할당이 가능하다.
- const와 let은 블럭 레벨 스코프를 취하기 때문에 조건문, 중괄호로 이루어진 블럭 내부에서 선언되었다면 외부에서 해당 변수에 대한 참조가 불가능해진다. let과 const는 재할당이 불가능하다.
- var의 경우 선언과 메모리 할당 초기화 처리가 동시에 이루어지므로 선언된 변수에 대한 참조가 가능하다. 하지만 let과 const는 선언만 이루어지므로 선언 이전에는 해당 변수에 대한 참조가 불가능하다.

### 클로저란?

- 클로저는 선언 당시의 함수가 스코프 체인의 도움으로 전역 범위에 도달할 때까지 현재 범위와 상위 함수의 범위, 그리고 그 상위 함수의 범위까지에 대한 변수와 매개변수를 기억하는 능력이다.
- 클로저는 현재 상태를 기억하고, 변경된 최신 상태를 유지하기 위해 사용하며, 전역 변수의 사용을 억제하고 정보를 은닉, 실수를 줄이기 위해 사용한다.

### 실행 컨텍스트란?

- 실행 가능한 코드가 실행되기 위해 필요한 환경을 의미한다. 실행 컨텍스트는 스코프, this의 동작원리를 담고 있는 것을 말한다.
- 전역 컨텍스트와 함수 컨텍스트 2가지가 존재하며, 전역 컨텍스트 생성 후에 함수가 호출될 때마다 함수 컨텍스트가 생성된다.
- 컨텍스트 생성시 변수 객체, 스코프 체인, this가 생성된다. 컨텍스트 생성 후 함수에 사용되는 변수들은 변수 객체 안에서 값을 찾고 없다면 스코프 체인을 따라 올라가며 찾는다.
- 함수 실행이 마무리되면 해당 컨텍스트는 사라지고, 페이지가 종료되면 전역 컨텍스트도 사라진다.
  1. 변수객체
  - 실행 컨텍스트가 생성되면, 자바스크립트 엔진은 실행을 위해 필요한 여러 정보들을 담을 객체를 생성하는데, 이것이 변수 객체이다. 전역 컨텍스트는 변수 객체 안에 전역 함수 및 전역 변수를 저장하며, 함수 컨텍스트인 경우 이와 더불어 argument object를 함께 저장한다.
  2. 스코프 체인
  - 스코프 체인은 일종의 리스트로써 전역 객체와 중첩된 함수의 레퍼런스를 차례로 저장한다. 전역 또는 함수가 참조할 수 있는 변수 객체에 대해 저장하게 되며, 이는 실행 컨텍스트에서 상위 컨텍스트와 그 상위 컨텍스트의 변수 객체, 마지막으로는 전역 객체까지 참조할 수 있게된다. 자바스크립트 엔진은 스코프 체인을 통해 렉시컬 스코프를 파악한다. 상위 함수, 전역 스코프 등을 참조할 수 있는 이유가 스코프 체인이 검색을 하기 때문이다.. (렉시컬 환경은 식별자와 식별자에 바인딩된 값, 그리고 상위 스코프에 대한 참조를 기록하는 자료구조로 실행 컨텍스트를 구성하는 컴포넌트이다.)
  3. This
  - this에 할당되는 값은 함수의 호출 패턴에 의해 결정된다.

### 호이스팅이란?

- 호이스팅이란 변수를 선언하고 초기화했을 때 선언 부분이 최상단으로 끌어올려지는 현상이다. 함수 표현식은 호이스팅이 적용되지 않고, 일반 함수 선언문은 함수 호이스팅이 적용된다.

### 프로토 타입이란?

- 자바스크립트는 프로토타입을 기반으로 상속을 구현하여 불필요한 중복을 제거했다. 기존의 코드를 재사용하여 중복을 제거하였으며, 생성자 함수가 생성할 모든 인스턴스가 공통적으로 사용할 프로퍼티나 메소드를 미리 프로토타입에 구현해 놓음으로써 상위 객체인 프로토타입의 자산을 공유하여 사용할 수 있다.

### 프로토타입 체인?

- 객체의 프로퍼티에 접근하려고 할 때, 객체에 접근하려는 프로퍼티가 없으면,**proto**접근자 프로퍼티가 가리키는 링크를 따라 자신의 부모역할을 하는 프로토타입의 프로퍼티를 순차적으로 검색하는 것을 말한다.
- 프로토타입체인의 최상위 객체는 Object.prototype이다.

### 불변성을 유지하려면 어떻게 해야하는가?

1. 스프레드 문법 사용

- 스프레드 문법을 사용해서 객체를 복사하면 객체가 불변성을 유지할 수 있다. 스프레드 문법을 1레벨 깊이에서만 유효하게 동작하기 때문에 객체 내부 객체의 불변성까지는 유지할 수 없다.

2. immer 라이브러리 사용
